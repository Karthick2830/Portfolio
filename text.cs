using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.Interaction.Toolkit;
using TMPro;
public class VRAssemblyGameManager : MonoBehaviour
{
    [System.Serializable] public class ComponentStep { public string stepName; [Header("Step Audios")]
        public AudioClip[] stepAudios; 
        0=component, 1=board, 2=LED, 3=iron public AudioClip solderCompleteAudio; [Header("Components & Sockets")] public GameObject component; public GameObject componentSocket; public GameObject board; public GameObject boardSocket; public GameObject solderWireLED; public GameObject[] highlights; public GameObject solderingIronTip; [Header("Solder Results")] public GameObject[] solderedResultPrefabs; public Transform[] spawnPoints; [Header("Controller")] public ActionBasedController hapticController; [Header("Step Arrows")] public GameObject componentArrow; public GameObject boardArrow; public GameObject ledArrow; public GameObject ironArrow; public GameObject boardSocketArrow; [Header("Smoke Effect")] public GameObject smokeEffectPrefab; [Header("Custom Step Options")] public bool boardFirst = false; public bool useExtraComponents = false; public GameObject[] extraComponents; public GameObject[] extraComponentSockets; public AudioClip[] extraComponentAudios; [Header("UI Text for Steps")] public GameObject stepPanel; public TextMeshProUGUI stepTextUI; [TextArea] public string stepContent; [TextArea] public string[] substepContents; // 0=component,1=board,2=LED,3=iron [HideInInspector] public bool[] solderedPins; } public List<ComponentStep> steps = new List<ComponentStep>(); public AudioSource audioSource; private int currentStepIndex = 0; void Start() { foreach (var step in steps) { foreach (var h in step.highlights) if (h != null) h.SetActive(false); if (step.boardSocketArrow != null) step.boardSocketArrow.SetActive(false); if (step.stepPanel != null) step.stepPanel.SetActive(false); // hide all panels initially } StartCoroutine(RunAssemblySteps()); } IEnumerator RunAssemblySteps() { while (currentStepIndex < steps.Count) { ComponentStep step = steps[currentStepIndex]; step.solderedPins = new bool[step.spawnPoints.Length]; // ✅ show panel & initial text if (step.stepPanel != null) { step.stepPanel.SetActive(true); if (step.stepTextUI != null) step.stepTextUI.text = step.stepContent; } // --- Board-first vs Component-first --- if (step.boardFirst) { UpdateSubstepText(step, 1); // board if (step.boardArrow != null) step.boardArrow.SetActive(true); if (step.boardSocketArrow != null) step.boardSocketArrow.SetActive(true); PlayAudio(step.stepAudios[1]); yield return new WaitUntil(() => IsInSocket(step.board, step.boardSocket)); if (step.boardArrow != null) step.boardArrow.SetActive(false); if (step.boardSocketArrow != null) step.boardSocketArrow.SetActive(false); UpdateSubstepText(step, 0); // component if (step.componentArrow != null) step.componentArrow.SetActive(true); PlayAudio(step.stepAudios[0]); yield return new WaitUntil(() => IsInSocket(step.component, step.componentSocket)); if (step.componentArrow != null) step.componentArrow.SetActive(false); } else { UpdateSubstepText(step, 0); // component if (step.componentArrow != null) step.componentArrow.SetActive(true); PlayAudio(step.stepAudios[0]); yield return new WaitUntil(() => IsInSocket(step.component, step.componentSocket)); if (step.componentArrow != null) step.componentArrow.SetActive(false); UpdateSubstepText(step, 1); // board if (step.boardArrow != null) step.boardArrow.SetActive(true); if (step.boardSocketArrow != null) step.boardSocketArrow.SetActive(true); PlayAudio(step.stepAudios[1]); yield return new WaitUntil(() => IsInSocket(step.board, step.boardSocket)); if (step.boardArrow != null) step.boardArrow.SetActive(false); if (step.boardSocketArrow != null) step.boardSocketArrow.SetActive(false); } // --- Extra components or soldering --- if (step.useExtraComponents && step.extraComponents.Length == step.extraComponentSockets.Length) { for (int i = 0; i < step.extraComponents.Length; i++) { yield return new WaitUntil(() => IsInSocket(step.extraComponents[i], step.extraComponentSockets[i])); if (step.extraComponentAudios != null && i < step.extraComponentAudios.Length && step.extraComponentAudios[i] != null) PlayAudio(step.extraComponentAudios[i]); else PlayAudio(step.stepAudios[0]); } if (step.solderCompleteAudio != null) { PlayAudio(step.solderCompleteAudio); yield return new WaitWhile(() => audioSource.isPlaying); } } else { UpdateSubstepText(step, 2); // LED if (step.ledArrow != null) step.ledArrow.SetActive(true); PlayAudio(step.stepAudios[2]); foreach (var h in step.highlights) if (h != null) h.SetActive(true); yield return new WaitUntil(() => IsInSocket(step.solderWireLED, step.highlights[0])); if (step.ledArrow != null) step.ledArrow.SetActive(false); UpdateSubstepText(step, 3); // iron if (step.ironArrow != null) step.ironArrow.SetActive(true); PlayAudio(step.stepAudios[3]); yield return StartCoroutine(HandleMultipleSoldering(step)); if (step.solderCompleteAudio != null) { PlayAudio(step.solderCompleteAudio); yield return new WaitWhile(() => audioSource.isPlaying); } if (step.ironArrow != null) step.ironArrow.SetActive(false); foreach (var h in step.highlights) if (h != null) h.SetActive(false); } // ✅ hide panel after step if (step.stepPanel != null) step.stepPanel.SetActive(false); currentStepIndex++; } } // --- helper for substep text --- void UpdateSubstepText(ComponentStep step, int index) { if (step.stepTextUI != null && step.substepContents != null && index < step.substepContents.Length) { if (!string.IsNullOrEmpty(step.substepContents[index])) step.stepTextUI.text = step.substepContents[index]; } } // --- existing methods unchanged --- IEnumerator HandleMultipleSoldering(ComponentStep step) { /* your soldering code here */ yield break; } IEnumerator MeltLED(GameObject led) { yield break; } void PlayAudio(AudioClip clip) { if (clip != null && audioSource != null) { audioSource.clip = clip; audioSource.Play(); } } bool IsInSocket(GameObject obj1, GameObject obj2) { return Vector3.Distance(obj1.transform.position, obj2.transform.position) < 0.05f; } bool AllPinsSoldered(ComponentStep step) { foreach (bool pinDone in step.solderedPins) if (!pinDone) return false; return true; } }